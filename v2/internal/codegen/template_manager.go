package codegen

import (
	"embed"
	"fmt"
	"path/filepath"
	"strings"
)

//go:embed templates/*
var templateFS embed.FS

// TemplateManager manages code generation templates
type TemplateManager struct {
	templates map[string]map[string]string // language -> template_name -> content
}

// NewTemplateManager creates a new template manager
func NewTemplateManager() *TemplateManager {
	tm := &TemplateManager{
		templates: make(map[string]map[string]string),
	}
	
	// Load embedded templates
	tm.loadEmbeddedTemplates()
	
	return tm
}

// loadEmbeddedTemplates loads templates from embedded filesystem
func (tm *TemplateManager) loadEmbeddedTemplates() {
	// Define template structure
	languages := []string{"go", "typescript", "python", "java"}
	templateTypes := []string{"client", "models", "types", "test"}
	
	for _, lang := range languages {
		tm.templates[lang] = make(map[string]string)
		
		for _, templateType := range templateTypes {
			filePath := fmt.Sprintf("templates/%s/%s.tmpl", lang, templateType)
			content, err := templateFS.ReadFile(filePath)
			if err == nil {
				tm.templates[lang][templateType] = string(content)
			}
		}
	}
	
	// Load additional templates if they exist
	tm.loadAdditionalTemplates()
}

// loadAdditionalTemplates loads additional language-specific templates
func (tm *TemplateManager) loadAdditionalTemplates() {
	// Go-specific templates
	if tm.templates["go"] == nil {
		tm.templates["go"] = make(map[string]string)
	}
	tm.templates["go"]["client"] = goClientTemplate
	tm.templates["go"]["models"] = goModelsTemplate
	tm.templates["go"]["types"] = goTypesTemplate
	tm.templates["go"]["test"] = goTestTemplate
	
	// TypeScript-specific templates
	if tm.templates["typescript"] == nil {
		tm.templates["typescript"] = make(map[string]string)
	}
	tm.templates["typescript"]["client"] = typeScriptClientTemplate
	tm.templates["typescript"]["models"] = typeScriptModelsTemplate
	tm.templates["typescript"]["types"] = typeScriptTypesTemplate
	tm.templates["typescript"]["test"] = typeScriptTestTemplate
	
	// Python-specific templates
	if tm.templates["python"] == nil {
		tm.templates["python"] = make(map[string]string)
	}
	tm.templates["python"]["client"] = pythonClientTemplate
	tm.templates["python"]["models"] = pythonModelsTemplate
	tm.templates["python"]["types"] = pythonTypesTemplate
	tm.templates["python"]["test"] = pythonTestTemplate
	
	// Java-specific templates
	if tm.templates["java"] == nil {
		tm.templates["java"] = make(map[string]string)
	}
	tm.templates["java"]["client"] = javaClientTemplate
	tm.templates["java"]["models"] = javaModelsTemplate
	tm.templates["java"]["types"] = javaTypesTemplate
	tm.templates["java"]["test"] = javaTestTemplate
}

// GetTemplate retrieves a template by language and name
func (tm *TemplateManager) GetTemplate(language, templateName string) (string, error) {
	langTemplates, exists := tm.templates[language]
	if !exists {
		return "", fmt.Errorf("language %s not supported", language)
	}
	
	template, exists := langTemplates[templateName]
	if !exists {
		return "", fmt.Errorf("template %s not found for language %s", templateName, language)
	}
	
	return template, nil
}

// GetTemplatesForLanguage retrieves all templates for a language
func (tm *TemplateManager) GetTemplatesForLanguage(language string) (map[string]string, error) {
	langTemplates, exists := tm.templates[language]
	if !exists {
		return nil, fmt.Errorf("language %s not supported", language)
	}
	
	// Return a copy to prevent modification
	result := make(map[string]string)
	for name, content := range langTemplates {
		result[name] = content
	}
	
	return result, nil
}

// GetSupportedLanguages returns list of supported languages
func (tm *TemplateManager) GetSupportedLanguages() []string {
	languages := make([]string, 0, len(tm.templates))
	for lang := range tm.templates {
		languages = append(languages, lang)
	}
	return languages
}

// GetTemplateNames returns template names for a language
func (tm *TemplateManager) GetTemplateNames(language string) ([]string, error) {
	langTemplates, exists := tm.templates[language]
	if !exists {
		return nil, fmt.Errorf("language %s not supported", language)
	}
	
	names := make([]string, 0, len(langTemplates))
	for name := range langTemplates {
		names = append(names, name)
	}
	return names, nil
}

// AddTemplate adds a custom template
func (tm *TemplateManager) AddTemplate(language, templateName, content string) {
	if tm.templates[language] == nil {
		tm.templates[language] = make(map[string]string)
	}
	tm.templates[language][templateName] = content
}

// Template constants for different languages

const goClientTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
)

// {{.ClassName}} represents a client for the {{.Workflow.Name}} workflow
type {{.ClassName}} struct {
	baseURL    string
	httpClient *http.Client
	apiKey     string
}

// New{{.ClassName}} creates a new workflow client
func New{{.ClassName}}(baseURL, apiKey string) *{{.ClassName}} {
	return &{{.ClassName}}{
		baseURL: baseURL,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		apiKey: apiKey,
	}
}

// ExecuteWorkflow executes the {{.Workflow.Name}} workflow
func (c *{{.ClassName}}) ExecuteWorkflow(ctx context.Context, input map[string]interface{}) (*ExecutionResult, error) {
	payload := map[string]interface{}{
		"workflow_id": "{{.Workflow.ID}}",
		"input":       input,
	}

	jsonData, err := json.Marshal(payload)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/api/v2/executions", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+c.apiKey)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("request failed with status: %d", resp.StatusCode)
	}

	var result ExecutionResult
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &result, nil
}

{{range .Methods}}
// {{.Name}} executes the {{.Description}} step
func (c *{{$.ClassName}}) {{.Name}}(ctx context.Context{{range .Parameters}}, {{.Name}} {{.Type}}{{end}}) ({{.ReturnType}}, error) {
	input := map[string]interface{}{
		{{range .Parameters}}"{{.Name}}": {{.Name}},
		{{end}}
	}

	result, err := c.ExecuteWorkflow(ctx, input)
	if err != nil {
		return nil, fmt.Errorf("failed to execute {{.Name}}: %w", err)
	}

	return result.Output, nil
}
{{end}}

// GetExecutionStatus gets the status of an execution
func (c *{{.ClassName}}) GetExecutionStatus(ctx context.Context, executionID uuid.UUID) (*ExecutionStatus, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/api/v2/executions/%s/status", c.baseURL, executionID), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+c.apiKey)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("request failed with status: %d", resp.StatusCode)
	}

	var status ExecutionStatus
	if err := json.NewDecoder(resp.Body).Decode(&status); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &status, nil
}
`

const goModelsTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}}

import (
	"time"

	"github.com/google/uuid"
)

// ExecutionResult represents the result of a workflow execution
type ExecutionResult struct {
	ID          uuid.UUID              ` + "`json:\"id\"`" + `
	WorkflowID  uuid.UUID              ` + "`json:\"workflow_id\"`" + `
	Status      string                 ` + "`json:\"status\"`" + `
	Output      map[string]interface{} ` + "`json:\"output\"`" + `
	Error       string                 ` + "`json:\"error,omitempty\"`" + `
	StartedAt   time.Time              ` + "`json:\"started_at\"`" + `
	CompletedAt *time.Time             ` + "`json:\"completed_at,omitempty\"`" + `
	Duration    *time.Duration         ` + "`json:\"duration,omitempty\"`" + `
}

// ExecutionStatus represents the status of a workflow execution
type ExecutionStatus struct {
	ID       uuid.UUID ` + "`json:\"id\"`" + `
	Status   string    ` + "`json:\"status\"`" + `
	Progress float64   ` + "`json:\"progress\"`" + `
	Message  string    ` + "`json:\"message,omitempty\"`" + `
	Steps    []StepStatus ` + "`json:\"steps\"`" + `
}

// StepStatus represents the status of a workflow step
type StepStatus struct {
	ID       string    ` + "`json:\"id\"`" + `
	Name     string    ` + "`json:\"name\"`" + `
	Status   string    ` + "`json:\"status\"`" + `
	StartedAt *time.Time ` + "`json:\"started_at,omitempty\"`" + `
	CompletedAt *time.Time ` + "`json:\"completed_at,omitempty\"`" + `
	Error    string    ` + "`json:\"error,omitempty\"`" + `
}

{{range .Models}}
// {{.Name}} represents {{.Description}}
type {{.Name}} struct {
	{{range .Fields}}{{.Name}} {{.Type}} ` + "`{{range $key, $value := .Tags}}{{$key}}:\"{{$value}}\" {{end}}`" + `
	{{end}}
}
{{end}}
`

const goTypesTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}}

// Workflow constants
const (
	WorkflowID   = "{{.Workflow.ID}}"
	WorkflowName = "{{.Workflow.Name}}"
)

// Step constants
const (
	{{range .Workflow.Definition.Steps}}Step{{.ID | toPascalCase}} = "{{.ID}}"
	{{end}}
)

// Status constants
const (
	StatusPending   = "pending"
	StatusRunning   = "running"
	StatusCompleted = "completed"
	StatusFailed    = "failed"
	StatusCancelled = "cancelled"
)
`

const goTestTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}}

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func Test{{.ClassName}}_ExecuteWorkflow(t *testing.T) {
	client := New{{.ClassName}}("http://localhost:8080", "test-api-key")
	
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	
	input := map[string]interface{}{
		"test": "value",
	}
	
	result, err := client.ExecuteWorkflow(ctx, input)
	require.NoError(t, err)
	require.NotNil(t, result)
	
	assert.Equal(t, WorkflowID, result.WorkflowID.String())
	assert.NotEmpty(t, result.ID)
}

{{range .Methods}}
func Test{{$.ClassName}}_{{.Name}}(t *testing.T) {
	client := New{{$.ClassName}}("http://localhost:8080", "test-api-key")
	
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	
	{{range .Parameters}}{{.Name}} := {{if eq .Type "string"}}"test-value"{{else if eq .Type "int"}}123{{else if eq .Type "bool"}}true{{else}}nil{{end}}
	{{end}}
	
	result, err := client.{{.Name}}(ctx{{range .Parameters}}, {{.Name}}{{end}})
	require.NoError(t, err)
	require.NotNil(t, result)
}
{{end}}
`

// TypeScript templates
const typeScriptClientTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

import { ExecutionResult, ExecutionStatus } from './types';

export interface {{.ClassName}}Config {
  baseURL: string;
  apiKey: string;
  timeout?: number;
}

export class {{.ClassName}} {
  private baseURL: string;
  private apiKey: string;
  private timeout: number;

  constructor(config: {{.ClassName}}Config) {
    this.baseURL = config.baseURL;
    this.apiKey = config.apiKey;
    this.timeout = config.timeout || 30000;
  }

  async executeWorkflow(input: Record<string, any>): Promise<ExecutionResult> {
    const payload = {
      workflow_id: '{{.Workflow.ID}}',
      input
    };

    const response = await fetch(\`\${this.baseURL}/api/v2/executions\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': \`Bearer \${this.apiKey}\`
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      throw new Error(\`Request failed with status: \${response.status}\`);
    }

    return response.json();
  }

{{range .Methods}}
  async {{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name}}: {{$param.Type}}{{end}}): Promise<any> {
    const input = {
      {{range .Parameters}}{{.Name}},
      {{end}}
    };

    const result = await this.executeWorkflow(input);
    return result.output;
  }
{{end}}

  async getExecutionStatus(executionId: string): Promise<ExecutionStatus> {
    const response = await fetch(\`\${this.baseURL}/api/v2/executions/\${executionId}/status\`, {
      headers: {
        'Authorization': \`Bearer \${this.apiKey}\`
      }
    });

    if (!response.ok) {
      throw new Error(\`Request failed with status: \${response.status}\`);
    }

    return response.json();
  }
}
`

const typeScriptModelsTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

export interface ExecutionResult {
  id: string;
  workflow_id: string;
  status: string;
  output: Record<string, any>;
  error?: string;
  started_at: string;
  completed_at?: string;
  duration?: number;
}

export interface ExecutionStatus {
  id: string;
  status: string;
  progress: number;
  message?: string;
  steps: StepStatus[];
}

export interface StepStatus {
  id: string;
  name: string;
  status: string;
  started_at?: string;
  completed_at?: string;
  error?: string;
}

{{range .Models}}
export interface {{.Name}} {
  {{range .Fields}}{{.Name}}: {{.Type}};
  {{end}}
}
{{end}}
`

const typeScriptTypesTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

export const WORKFLOW_ID = '{{.Workflow.ID}}';
export const WORKFLOW_NAME = '{{.Workflow.Name}}';

export const STEPS = {
  {{range .Workflow.Definition.Steps}}{{.ID | upper}}: '{{.ID}}',
  {{end}}
} as const;

export const STATUS = {
  PENDING: 'pending',
  RUNNING: 'running',
  COMPLETED: 'completed',
  FAILED: 'failed',
  CANCELLED: 'cancelled'
} as const;

export type WorkflowStatus = typeof STATUS[keyof typeof STATUS];
`

const typeScriptTestTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

import { {{.ClassName}} } from './client';
import { WORKFLOW_ID } from './types';

describe('{{.ClassName}}', () => {
  let client: {{.ClassName}};

  beforeEach(() => {
    client = new {{.ClassName}}({
      baseURL: 'http://localhost:8080',
      apiKey: 'test-api-key'
    });
  });

  it('should execute workflow', async () => {
    const input = { test: 'value' };
    const result = await client.executeWorkflow(input);
    
    expect(result).toBeDefined();
    expect(result.workflow_id).toBe(WORKFLOW_ID);
    expect(result.id).toBeDefined();
  });

{{range .Methods}}
  it('should execute {{.Name}}', async () => {
    {{range .Parameters}}const {{.Name}} = {{if eq .Type "string"}}'test-value'{{else if eq .Type "number"}}123{{else if eq .Type "boolean"}}true{{else}}null{{end}};
    {{end}}
    
    const result = await client.{{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name}}{{end}});
    expect(result).toBeDefined();
  });
{{end}}
});
`

// Python templates
const pythonClientTemplate = `# Code generated by Magic Flow v2. DO NOT EDIT.
# Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

import json
import requests
from typing import Dict, Any, Optional
from .types import ExecutionResult, ExecutionStatus

class {{.ClassName}}:
    """Client for the {{.Workflow.Name}} workflow"""
    
    def __init__(self, base_url: str, api_key: str, timeout: int = 30):
        self.base_url = base_url
        self.api_key = api_key
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        })
    
    def execute_workflow(self, input_data: Dict[str, Any]) -> ExecutionResult:
        """Execute the {{.Workflow.Name}} workflow"""
        payload = {
            'workflow_id': '{{.Workflow.ID}}',
            'input': input_data
        }
        
        response = self.session.post(
            f'{self.base_url}/api/v2/executions',
            json=payload,
            timeout=self.timeout
        )
        response.raise_for_status()
        
        return ExecutionResult(**response.json())
    
{{range .Methods}}
    def {{.Name | toSnakeCase}}(self{{range .Parameters}}, {{.Name | toSnakeCase}}: {{.Type}}{{end}}) -> Any:
        """Execute the {{.Description}} step"""
        input_data = {
            {{range .Parameters}}'{{.Name}}': {{.Name | toSnakeCase}},
            {{end}}
        }
        
        result = self.execute_workflow(input_data)
        return result.output
    
{{end}}
    def get_execution_status(self, execution_id: str) -> ExecutionStatus:
        """Get the status of an execution"""
        response = self.session.get(
            f'{self.base_url}/api/v2/executions/{execution_id}/status',
            timeout=self.timeout
        )
        response.raise_for_status()
        
        return ExecutionStatus(**response.json())
`

const pythonModelsTemplate = `# Code generated by Magic Flow v2. DO NOT EDIT.
# Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

from dataclasses import dataclass
from typing import Dict, Any, Optional, List
from datetime import datetime

@dataclass
class ExecutionResult:
    id: str
    workflow_id: str
    status: str
    output: Dict[str, Any]
    started_at: datetime
    error: Optional[str] = None
    completed_at: Optional[datetime] = None
    duration: Optional[float] = None

@dataclass
class StepStatus:
    id: str
    name: str
    status: str
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error: Optional[str] = None

@dataclass
class ExecutionStatus:
    id: str
    status: str
    progress: float
    steps: List[StepStatus]
    message: Optional[str] = None

{{range .Models}}
@dataclass
class {{.Name}}:
    """{{.Description}}"""
    {{range .Fields}}{{.Name | toSnakeCase}}: {{.Type}}
    {{end}}
{{end}}
`

const pythonTypesTemplate = `# Code generated by Magic Flow v2. DO NOT EDIT.
# Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

WORKFLOW_ID = '{{.Workflow.ID}}'
WORKFLOW_NAME = '{{.Workflow.Name}}'

class Steps:
    {{range .Workflow.Definition.Steps}}{{.ID | upper}} = '{{.ID}}'
    {{end}}

class Status:
    PENDING = 'pending'
    RUNNING = 'running'
    COMPLETED = 'completed'
    FAILED = 'failed'
    CANCELLED = 'cancelled'
`

const pythonTestTemplate = `# Code generated by Magic Flow v2. DO NOT EDIT.
# Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

import pytest
from .client import {{.ClassName}}
from .types import WORKFLOW_ID

class Test{{.ClassName}}:
    def setup_method(self):
        self.client = {{.ClassName}}(
            base_url='http://localhost:8080',
            api_key='test-api-key'
        )
    
    def test_execute_workflow(self):
        input_data = {'test': 'value'}
        result = self.client.execute_workflow(input_data)
        
        assert result is not None
        assert result.workflow_id == WORKFLOW_ID
        assert result.id is not None
    
{{range .Methods}}
    def test_{{.Name | toSnakeCase}}(self):
        {{range .Parameters}}{{.Name | toSnakeCase}} = {{if eq .Type "str"}}'test-value'{{else if eq .Type "int"}}123{{else if eq .Type "bool"}}True{{else}}None{{end}}
        {{end}}
        
        result = self.client.{{.Name | toSnakeCase}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name | toSnakeCase}}{{end}})
        assert result is not None
    
{{end}}
`

// Java templates
const javaClientTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}};

import com.fasterxml.jackson.databind.ObjectMapper;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URI;
import java.time.Duration;
import java.util.Map;

public class {{.ClassName}} {
    private final String baseUrl;
    private final String apiKey;
    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;
    
    public {{.ClassName}}(String baseUrl, String apiKey) {
        this.baseUrl = baseUrl;
        this.apiKey = apiKey;
        this.httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(30))
            .build();
        this.objectMapper = new ObjectMapper();
    }
    
    public ExecutionResult executeWorkflow(Map<String, Object> input) throws Exception {
        Map<String, Object> payload = Map.of(
            "workflow_id", "{{.Workflow.ID}}",
            "input", input
        );
        
        String jsonPayload = objectMapper.writeValueAsString(payload);
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/api/v2/executions"))
            .header("Content-Type", "application/json")
            .header("Authorization", "Bearer " + apiKey)
            .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))
            .build();
        
        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            throw new RuntimeException("Request failed with status: " + response.statusCode());
        }
        
        return objectMapper.readValue(response.body(), ExecutionResult.class);
    }
    
{{range .Methods}}
    public Object {{.Name | toCamelCase}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Type}} {{$param.Name | toCamelCase}}{{end}}) throws Exception {
        Map<String, Object> input = Map.of(
            {{range $i, $param := .Parameters}}{{if $i}}, {{end}}"{{$param.Name}}", {{$param.Name | toCamelCase}}{{end}}
        );
        
        ExecutionResult result = executeWorkflow(input);
        return result.getOutput();
    }
    
{{end}}
    public ExecutionStatus getExecutionStatus(String executionId) throws Exception {
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/api/v2/executions/" + executionId + "/status"))
            .header("Authorization", "Bearer " + apiKey)
            .GET()
            .build();
        
        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            throw new RuntimeException("Request failed with status: " + response.statusCode());
        }
        
        return objectMapper.readValue(response.body(), ExecutionStatus.class);
    }
}
`

const javaModelsTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}};

import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

public class ExecutionResult {
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("workflow_id")
    private String workflowId;
    
    @JsonProperty("status")
    private String status;
    
    @JsonProperty("output")
    private Map<String, Object> output;
    
    @JsonProperty("error")
    private String error;
    
    @JsonProperty("started_at")
    private LocalDateTime startedAt;
    
    @JsonProperty("completed_at")
    private LocalDateTime completedAt;
    
    @JsonProperty("duration")
    private Long duration;
    
    // Getters and setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getWorkflowId() { return workflowId; }
    public void setWorkflowId(String workflowId) { this.workflowId = workflowId; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    
    public Map<String, Object> getOutput() { return output; }
    public void setOutput(Map<String, Object> output) { this.output = output; }
    
    public String getError() { return error; }
    public void setError(String error) { this.error = error; }
    
    public LocalDateTime getStartedAt() { return startedAt; }
    public void setStartedAt(LocalDateTime startedAt) { this.startedAt = startedAt; }
    
    public LocalDateTime getCompletedAt() { return completedAt; }
    public void setCompletedAt(LocalDateTime completedAt) { this.completedAt = completedAt; }
    
    public Long getDuration() { return duration; }
    public void setDuration(Long duration) { this.duration = duration; }
}

public class ExecutionStatus {
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("status")
    private String status;
    
    @JsonProperty("progress")
    private double progress;
    
    @JsonProperty("message")
    private String message;
    
    @JsonProperty("steps")
    private List<StepStatus> steps;
    
    // Getters and setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    
    public double getProgress() { return progress; }
    public void setProgress(double progress) { this.progress = progress; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public List<StepStatus> getSteps() { return steps; }
    public void setSteps(List<StepStatus> steps) { this.steps = steps; }
}

public class StepStatus {
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("status")
    private String status;
    
    @JsonProperty("started_at")
    private LocalDateTime startedAt;
    
    @JsonProperty("completed_at")
    private LocalDateTime completedAt;
    
    @JsonProperty("error")
    private String error;
    
    // Getters and setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    
    public LocalDateTime getStartedAt() { return startedAt; }
    public void setStartedAt(LocalDateTime startedAt) { this.startedAt = startedAt; }
    
    public LocalDateTime getCompletedAt() { return completedAt; }
    public void setCompletedAt(LocalDateTime completedAt) { this.completedAt = completedAt; }
    
    public String getError() { return error; }
    public void setError(String error) { this.error = error; }
}

{{range .Models}}
public class {{.Name}} {
    {{range .Fields}}@JsonProperty("{{.Name | toSnakeCase}}")
    private {{.Type}} {{.Name | toCamelCase}};
    
    {{end}}
    
    {{range .Fields}}public {{.Type}} get{{.Name | toPascalCase}}() { return {{.Name | toCamelCase}}; }
    public void set{{.Name | toPascalCase}}({{.Type}} {{.Name | toCamelCase}}) { this.{{.Name | toCamelCase}} = {{.Name | toCamelCase}}; }
    
    {{end}}
}
{{end}}
`

const javaTypesTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}};

public final class Constants {
    public static final String WORKFLOW_ID = "{{.Workflow.ID}}";
    public static final String WORKFLOW_NAME = "{{.Workflow.Name}}";
    
    public static final class Steps {
        {{range .Workflow.Definition.Steps}}public static final String {{.ID | upper}} = "{{.ID}}";
        {{end}}
    }
    
    public static final class Status {
        public static final String PENDING = "pending";
        public static final String RUNNING = "running";
        public static final String COMPLETED = "completed";
        public static final String FAILED = "failed";
        public static final String CANCELLED = "cancelled";
    }
    
    private Constants() {
        // Utility class
    }
}
`

const javaTestTemplate = `// Code generated by Magic Flow v2. DO NOT EDIT.
// Generated at: {{.GeneratedAt.Format "2006-01-02 15:04:05"}}

package {{.PackageName}};

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Map;

public class {{.ClassName}}Test {
    private {{.ClassName}} client;
    
    @BeforeEach
    public void setUp() {
        client = new {{.ClassName}}("http://localhost:8080", "test-api-key");
    }
    
    @Test
    public void testExecuteWorkflow() throws Exception {
        Map<String, Object> input = Map.of("test", "value");
        ExecutionResult result = client.executeWorkflow(input);
        
        assertNotNull(result);
        assertEquals(Constants.WORKFLOW_ID, result.getWorkflowId());
        assertNotNull(result.getId());
    }
    
{{range .Methods}}
    @Test
    public void test{{.Name | toPascalCase}}() throws Exception {
        {{range .Parameters}}{{.Type}} {{.Name | toCamelCase}} = {{if eq .Type "String"}}"test-value"{{else if eq .Type "int"}}123{{else if eq .Type "boolean"}}true{{else}}null{{end}};
        {{end}}
        
        Object result = client.{{.Name | toCamelCase}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name | toCamelCase}}{{end}});
        assertNotNull(result);
    }
    
{{end}}
}
`